cmake_minimum_required (VERSION 3.12)
project ("CARLA OSI Service" CXX)

message("Running with CMake Version ${CMAKE_MAJOR_VERSION}.${CMAKE_MINOR_VERSION}.${CMAKE_PATCH_VERSION}")

set(CMAKE_CXX_STANDARD 17)
set(CMAKE_CXX_STANDARD_REQUIRED ON)
set(CMAKE_CXX_EXTENSIONS OFF)

if(MSVC)
	option(DONT_FORCE_STATIC_LIBS "Building dynamic libraries fails for some targets because of incompatabilities in dependencies (protobuf, see FetchGRPC.cmake) and thus static lib's are enforced. Enable this option to abide CMAKE's BUILD_SHARED_LIBS variable" OFF)
	if(NOT DONT_FORCE_STATIC_LIBS)
		set(BUILD_SHARED_LIBS false)
		message("Forcing the use of static libraries as building dynamic libraries fails for some targets using MSVC because of incompatabilities in some dependencies. Enable DONT_FORCE_STATIC_LIBS to unforce this behaviour")
	endif(NOT DONT_FORCE_STATIC_LIBS)
endif(MSVC)

option(GIT_SUBMODULE "Check submodules during build" OFF)
if(GIT_SUBMODULE)
	find_package(Git QUIET)
	if(GIT_FOUND AND EXISTS "${PROJECT_SOURCE_DIR}/.git")
		message(STATUS "Updating submodules")
		execute_process(COMMAND ${GIT_EXECUTABLE} submodule update --init --recursive
						WORKING_DIRECTORY ${CMAKE_CURRENT_SOURCE_DIR}
						RESULT_VARIABLE GIT_SUBMODULE_RESULT)
		if(NOT GIT_SUBMODULE_RESULT EQUAL "0")
			message(FATAL_ERROR "git submodule update --init --recursive failed with ${GIT_SUBMODULE_RESULT}")
		endif()
	endif()
endif()

# Download automatically, you can also just copy the conan.cmake file
if(NOT EXISTS "${CMAKE_BINARY_DIR}/conan.cmake")
   message(STATUS "Downloading conan.cmake from https://github.com/conan-io/cmake-conan")
   file(DOWNLOAD "https://raw.githubusercontent.com/conan-io/cmake-conan/v0.16.1/conan.cmake"
                "${CMAKE_BINARY_DIR}/conan.cmake")
endif()

include(${CMAKE_BINARY_DIR}/conan.cmake)

# get dependencies distributed as conan packages
conan_cmake_run(CONANFILE conanfile.txt
                BASIC_SETUP CMAKE_TARGETS
                BUILD missing)
                
# include conan packages for protobuf, catch2, fakeit ...
include(${CMAKE_CURRENT_BINARY_DIR}/conanbuildinfo.cmake)

conan_basic_setup()

# Findprotobuf.cmake generated by cmake_find_package conan generator is missing some definitions from the default find script, but catch2 is not found without a defintion for find_package
find_program(Protobuf_PROTOC_EXECUTABLE
    NAMES protoc
    DOC "The Google Protocol Buffers Compiler"
    HINTS
	${CONAN_BIN_DIRS}
)
if(Protobuf_PROTOC_EXECUTABLE)# Newer CMake versions define only upper case names
	set(PROTOBUF_PROTOC_EXECUTABLE ${Protobuf_PROTOC_EXECUTABLE})
endif()

# Findprotobuf.cmake generated by cmake_find_package conan generator is missing some definitons from the default find script, but catch2 is not found without a defintion for find_package
# => We use our own FindCatch2.cmake module
set(CMAKE_MODULE_PATH ${CMAKE_CURRENT_SOURCE_DIR}/CMakeModules ${CMAKE_MODULE_PATH})

# Read CMake_FetchContent_Overrides for changes of FetchContent_declare default of other included scripts (currently applies to FetchLibCarla_Service, only)
include(FetchContent)
include(${CMAKE_CURRENT_LIST_DIR}/CMake_FetchContent_Overrides.cmake OPTIONAL)

# OSI is not distributed as conan package, but we already took care of installig its dependency (protobuf), so we can just fetch it
include(FetchOpenSimulationInterface)

# use CMake FetchContent Module to fetch LibCarla_client using our custom FetchLibCarla_client.cmake script
include(FetchLibCarla_client)

# use our FetchGRPC.cmake module to add gRPC
set(CMAKE_MODULE_PATH ${CMAKE_SOURCE_DIR}/CMakeModules ${CMAKE_MODULE_PATH})
include(FetchGRPC)



##main project
# set up variables that are used below
add_subdirectory("src")
add_subdirectory("include")
add_subdirectory("test")

if(MSVC)
  add_compile_options(/ZI)
endif()

#create library target
add_library(CARLA_OSI_Lib ${CARLA_OSI_LIB_SOURCE} ${CARLA_OSI_LIB_INCLUDES})
# CARLA_OSI_Lib exports no symbols, thereby preventing linking of its dll on windows. Force export of all global symbols
set_property(TARGET CARLA_OSI_Lib PROPERTY WINDOWS_EXPORT_ALL_SYMBOLS ON)
target_include_directories(CARLA_OSI_Lib PUBLIC ${CMAKE_CURRENT_LIST_DIR}/include)

#TBB needs to be explicitly linke in Linux
if(UNIX)
	target_link_libraries(CARLA_OSI_Lib PUBLIC CONAN_PKG::tbb)
	target_compile_options(CARLA_OSI_Lib PUBLIC -ltbb)
endif()

# link to conan managed dependencies
target_link_libraries(CARLA_OSI_Lib PUBLIC CONAN_PKG::protobuf CONAN_PKG::yaml-cpp)

# CARLA is not managed by conan, thus it is added here when enabled
target_link_libraries(CARLA_OSI_Lib PUBLIC LibCarla::LibCarla_client)

# OSI is not managed by conan, thus it is added here
target_include_directories(CARLA_OSI_Lib PUBLIC open_simulation_interface_obj)#shared base of both static and shared OSI lib targets
# OSI has differently named targets for static and shared build
if(BUILD_SHARED_LIBS)
	# By default, OSI exports no symbols when building a dll, preventing linking to the shared library on windows. Force export of all global symbols
	set_property(TARGET open_simulation_interface PROPERTY WINDOWS_EXPORT_ALL_SYMBOLS ON)
	target_link_libraries(CARLA_OSI_Lib PUBLIC open_simulation_interface)
else()
	target_link_libraries(CARLA_OSI_Lib PUBLIC open_simulation_interface_static)
endif(BUILD_SHARED_LIBS)


## generate grpc code
# include custom grcp cpp code generation script that is easier to use than gRPC's default function
include(GenerateGRPC)
# BaseInterface and CARLAInterface grpc Service for CoSiMa messages
# gRPC can handle relative files
set(COSIMA_GRPC_PROTO_FILES
	grpc_proto_files/CoSiMaMessages.proto
	grpc_proto_files/base_interface/BaseInterface.proto
	grpc_proto_files/base_interface/CARLAInterface.proto
)

add_library(CARLA_OSI_gRPC_Lib ${COSIMA_PROTO_SRCS} ${COSIMA_GRPC_SRCS} ${COSIMA_GRPC_PROTO_FILES})
generate_grpc_cpp(TARGET CARLA_OSI_gRPC_Lib IMPORT_DIRS ${CONAN_INCLUDE_DIRS_PROTOBUF} ${osi_SOURCE_DIR})
if(BUILD_SHARED_LIBS)
	target_link_libraries(CARLA_OSI_gRPC_Lib PUBLIC open_simulation_interface)
else()
	target_link_libraries(CARLA_OSI_gRPC_Lib PUBLIC open_simulation_interface_static)
endif()
target_link_libraries(CARLA_OSI_gRPC_Lib PUBLIC grpc++ grpc++_reflection)
target_include_directories(CARLA_OSI_gRPC_Lib BEFORE PUBLIC ${CMAKE_CURRENT_LIST_DIR}/include ${CMAKE_BINARY_DIR}/gens)

# receiver for ScenarioRunner TrafficCommands
set(SCENARIO_RUNNER_TRAFFIC_COMMAND_PROTO_FILES
    grpc_proto_files/srunner/ScenarioRunner.proto
)
add_library(CARLA_OSI_ScenarioRunner_gRPC_Lib ${SCENARIO_RUNNER_TRAFFIC_COMMAND_PROTO_FILES})
generate_grpc_cpp(TARGET CARLA_OSI_ScenarioRunner_gRPC_Lib IMPORT_DIRS ${CONAN_INCLUDE_DIRS_PROTOBUF} ${osi_SOURCE_DIR} ${osi_BINARY_DIR})
target_link_libraries(CARLA_OSI_ScenarioRunner_gRPC_Lib PUBLIC grpc++ grpc++_reflection)
target_include_directories(CARLA_OSI_ScenarioRunner_gRPC_Lib BEFORE PUBLIC ${CMAKE_CURRENT_LIST_DIR}/include ${CMAKE_BINARY_DIR}/gens)

# CALRA_OSI_gRPC_Lib depends on OSI because it reuses some messages as submessage (at least for sensor mounting positions)
if(BUILD_SHARED_LIBS)
	target_link_libraries(CARLA_OSI_gRPC_Lib PUBLIC open_simulation_interface)
	target_link_libraries(CARLA_OSI_ScenarioRunner_gRPC_Lib PUBLIC open_simulation_interface)
else()
	target_link_libraries(CARLA_OSI_gRPC_Lib PUBLIC open_simulation_interface_static)
	target_link_libraries(CARLA_OSI_ScenarioRunner_gRPC_Lib PUBLIC open_simulation_interface_static)
endif(BUILD_SHARED_LIBS)

# ScenarioRunner gRPC receiver library, separated to keep as an example when contributing to carla
add_library(CARLA_OSI_ScenarioRunner_Lib "${CMAKE_CURRENT_SOURCE_DIR}/src/ScenarioRunner/TrafficCommandReceiver.cpp"
                                         "${CMAKE_CURRENT_SOURCE_DIR}/include/ScenarioRunner/TrafficCommandReceiver.h")
target_link_libraries(CARLA_OSI_ScenarioRunner_Lib PUBLIC CARLA_OSI_ScenarioRunner_gRPC_Lib)
target_include_directories(CARLA_OSI_ScenarioRunner_Lib BEFORE PUBLIC ${CMAKE_CURRENT_SOURCE_DIR}/include ${CMAKE_BINARY_DIR}/gens)

# gRPC service logic library, separated from CARLA_OSI_Service to be testable with catch2
add_library(CARLA_OSI_gRPC_ServiceLib "${CMAKE_CURRENT_LIST_DIR}/src/CARLA_OSI_gRPC.cpp"
                                      "${CMAKE_CURRENT_LIST_DIR}/include/CARLA_OSI_gRPC.h")
target_link_libraries(CARLA_OSI_gRPC_ServiceLib PUBLIC CARLA_OSI_gRPC_Lib CARLA_OSI_Lib CARLA_OSI_ScenarioRunner_Lib)
target_include_directories(CARLA_OSI_gRPC_Lib BEFORE PUBLIC ${CMAKE_CURRENT_LIST_DIR}/include ${CMAKE_BINARY_DIR}/gens)

find_package(Catch2 REQUIRED)
add_executable(Test_CARLA_OSI ${TESTFILES})
target_include_directories(Test_CARLA_OSI PRIVATE ${CMAKE_CURRENT_LIST_DIR}/include ${CMAKE_CURRENT_LIST_DIR}/test)
target_link_libraries(Test_CARLA_OSI Catch2::Catch2 CARLA_OSI_Lib CARLA_OSI_gRPC_Lib CARLA_OSI_gRPC_ServiceLib)

include(CTest)
include(Catch)
catch_discover_tests(Test_CARLA_OSI)

add_executable (CARLA_OSI_Service "${CMAKE_CURRENT_LIST_DIR}/src/CARLA_OSI_Service.cpp")
if (${CMAKE_CXX_STANDARD} LESS 17)
target_link_libraries(CARLA_OSI_Service PUBLIC CARLA_OSI_Lib stdc++fs)
else()
target_link_libraries(CARLA_OSI_Service PUBLIC CARLA_OSI_Lib)
endif()
target_include_directories(CARLA_OSI_Service PRIVATE ${CMAKE_CURRENT_BINARY_DIR}/include/)
target_link_libraries(CARLA_OSI_Service PUBLIC CARLA_OSI_gRPC_ServiceLib)
# public include of target CARLA_OSI_gRPC_Lib is supposed to propagate, but is missing...
target_include_directories(CARLA_OSI_Service BEFORE PUBLIC ${CMAKE_BINARY_DIR}/gens)

# The import section in conanfile.txt is supposed to do the same, but somehow it stopped working.
# so far, only boost is needed. Additional globbing expressions can be added if needed
file(GLOB CONAN_BOOST_LIBS ${CONAN_BIN_DIRS_BOOST}/*.dll )
file(COPY ${CONAN_BOOST_LIBS} DESTINATION ${CMAKE_CURRENT_BINARY_DIR}/bin)
