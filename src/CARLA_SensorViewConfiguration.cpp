#include "CARLA_SensorViewConfiguration.h"

std::shared_ptr<osi3::SensorViewConfiguration> SensorViewConfiger::getLastSensorViewConfiguration()
{
	std::shared_ptr<osi3::SensorViewConfiguration> appliedSensorConfig = std::make_shared<osi3::SensorViewConfiguration>();
	auto sensorConfiguration = sensorsByFMU.at(sensorsByFMU.size() - 1);
	switch (sensorConfiguration.type) {
	case GENERIC:
	{
		auto* c = appliedSensorConfig->add_generic_sensor_view_configuration();
		c->CopyFrom(sensorConfiguration.sensorViewConfiguration.generic_sensor_view_configuration()[0]);
		c->mutable_sensor_id()->set_value(sensorConfiguration.id);
		break;
	}
	case RADAR:
	{
		auto* c = appliedSensorConfig->add_radar_sensor_view_configuration();
		c->CopyFrom(sensorConfiguration.sensorViewConfiguration.radar_sensor_view_configuration()[0]);
		c->mutable_sensor_id()->set_value(sensorConfiguration.id);
		break;
	}
	case LIDAR:
	{
		auto* c = appliedSensorConfig->add_lidar_sensor_view_configuration();
		c->CopyFrom(sensorConfiguration.sensorViewConfiguration.lidar_sensor_view_configuration()[0]);
		c->mutable_sensor_id()->set_value(sensorConfiguration.id);
		break;
	}
	case CAMERA:
	{
		auto* c = appliedSensorConfig->add_camera_sensor_view_configuration();;
		c->CopyFrom(sensorConfiguration.sensorViewConfiguration.camera_sensor_view_configuration()[0]);
		c->mutable_sensor_id()->set_value(sensorConfiguration.id);
		break;
	}
	case ULTRASONIC:
	{
		auto* c = appliedSensorConfig->add_ultrasonic_sensor_view_configuration();
		c->CopyFrom(sensorConfiguration.sensorViewConfiguration.ultrasonic_sensor_view_configuration()[0]);
		c->mutable_sensor_id()->set_value(sensorConfiguration.id);
		break;
	}
	}
	return appliedSensorConfig;
}

const osi3::MountingPosition SensorViewConfiger::getMountingPositionOfAnyGenericSensor() {
	for (auto& sensorConfig : sensorsByUser) {
		if (sensorConfig.type == SENSORTYPES::GENERIC
			&& sensorConfig.sensorViewConfiguration.has_mounting_position()) {
			return sensorConfig.sensorViewConfiguration.mounting_position();
		}
	}
	for (auto& sensorConfig : sensorsByFMU) {
		if (sensorConfig.type == SENSORTYPES::GENERIC
			&& sensorConfig.sensorViewConfiguration.has_mounting_position()) {
			return sensorConfig.sensorViewConfiguration.mounting_position();
		}
	}
	return osi3::MountingPosition();
}

void SensorViewConfiger::configureBP(carla::client::ActorBlueprint& sensorBP, const OSTARSensorConfiguration& sensorConfig) {
	switch (sensorConfig.type) {
	case SENSORTYPES::CAMERA:
		configureBPCamera(sensorBP, sensorConfig);
		break;
	case SENSORTYPES::LIDAR:
		configureBPLidar(sensorBP, sensorConfig);
		break;
	case SENSORTYPES::RADAR:
		configureBPRadar(sensorBP, sensorConfig);
		break;
	case SENSORTYPES::ULTRASONIC:

		break;
	case SENSORTYPES::GENERIC:

		break;
	default:
		std::cerr << "Type not supported!" << std::endl;
	}
}

void SensorViewConfiger::configureBPCamera(carla::client::ActorBlueprint& sensorBP, const OSTARSensorConfiguration& sensorConfig) {
	osi3::CameraSensorViewConfiguration camConf = sensorConfig.sensorViewConfiguration.camera_sensor_view_configuration(0);
	if (camConf.has_field_of_view_horizontal()) {
		//Horizontal field of view in degrees.
		sensorBP.SetAttribute("fov", std::to_string(Geometry::getInstance()->toCarla(camConf.field_of_view_horizontal())));
	}
	if (camConf.has_number_of_pixels_horizontal()) {
		//Image width in pixels.
		sensorBP.SetAttribute("image_size_x", std::to_string(camConf.number_of_pixels_horizontal()));
	}
	if (camConf.has_number_of_pixels_vertical()) {
		//Image width in pixels.
		sensorBP.SetAttribute("image_size_y", std::to_string(camConf.number_of_pixels_vertical()));
	}
}

void SensorViewConfiger::configureBPRadar(carla::client::ActorBlueprint& sensorBP, const OSTARSensorConfiguration& sensorConfig) {
	osi3::RadarSensorViewConfiguration radarConf = sensorConfig.sensorViewConfiguration.radar_sensor_view_configuration(0);
	if (radarConf.has_field_of_view_horizontal()) {
		//Horizontal field of view in degrees, 0 - 360.
		sensorBP.SetAttribute("horizontal_fov", std::to_string(Geometry::getInstance()->toCarla(radarConf.field_of_view_horizontal())));
	}
	if (radarConf.has_field_of_view_vertical()) {
		//Vertical field of view in degrees.
		sensorBP.SetAttribute("vertical_fov", std::to_string(Geometry::getInstance()->toCarla(radarConf.field_of_view_vertical() * 0.5)));
	}
	if (radarConf.has_number_of_rays_horizontal() && radarConf.has_number_of_rays_vertical()) {
		//Points generated by all lasers per second.
		sensorBP.SetAttribute("points_per_second", std::to_string(radarConf.number_of_rays_horizontal() * radarConf.number_of_rays_vertical() * (1 / runtimeParameter->deltaSeconds)));
	}
}

void SensorViewConfiger::configureBPLidar(carla::client::ActorBlueprint& sensorBP, const OSTARSensorConfiguration& sensorConfig) {
	osi3::LidarSensorViewConfiguration lidarConf = sensorConfig.sensorViewConfiguration.lidar_sensor_view_configuration(0);
	if (lidarConf.has_field_of_view_horizontal()) {
		//Range: [0.0, 1.0]
		sensorBP.SetAttribute("horizontal_fov", std::to_string(Geometry::getInstance()->toCarla(lidarConf.field_of_view_horizontal())));
	}
	if (lidarConf.has_field_of_view_vertical()) {
		//Angle in degrees of the highest laser.
		sensorBP.SetAttribute("upper_fov", std::to_string(Geometry::getInstance()->toCarla(lidarConf.field_of_view_vertical() * 0.5)));
		//Angle in degrees of the lowest laser.
		sensorBP.SetAttribute("lower_fov", std::to_string(Geometry::getInstance()->toCarla(lidarConf.field_of_view_vertical() * -0.5)));
	}
	if (lidarConf.has_number_of_rays_horizontal() && lidarConf.has_number_of_rays_vertical()) {
		//Points generated by all lasers per second.
		sensorBP.SetAttribute("points_per_second", std::to_string(lidarConf.number_of_rays_horizontal() * lidarConf.number_of_rays_vertical() * (1 / runtimeParameter->deltaSeconds)));
	}
	else if (lidarConf.has_num_of_pixels()) {
		//Points generated by all lasers per second.
		sensorBP.SetAttribute("points_per_second", std::to_string(lidarConf.num_of_pixels() * (1 / runtimeParameter->deltaSeconds)));
	}
}

bool SensorViewConfiger::getActorIdFromName(const std::string& roleName, carla::ActorId& actorId) {

	if (isSpawnedId(roleName, actorId)) {
		return true;
	}

	//if not spawned by Carla-OSI-Service, check all actors with role_name attribute

	auto worldActors = carla->world->GetActors();
	for (auto actor : *worldActors) {
		auto typeID = actor->GetTypeId();
		if (typeID.rfind("vehicle", 0) == 0) {
			auto vehicleActor = boost::static_pointer_cast<const carla::client::Vehicle>(actor);
			vehicleActor->GetAttributes();
			for (auto& attribute : vehicleActor->GetAttributes()) {
				if ("role_name" == attribute.GetId()) {
					if (attribute.GetValue() == roleName) {
						actorId = actor->GetId();
						return true;
					}
				}
			}
		}
	}
	return false;
}

std::string SensorViewConfiger::matchSensorType(const SENSORTYPES& type, const std::string& name) {
	switch (type) {
	case SENSORTYPES::CAMERA:
		return "sensor.camera.rgb";
	case SENSORTYPES::LIDAR:
		return "sensor.lidar.ray_cast_semantic";
	case SENSORTYPES::RADAR:
		return "sensor.other.radar";
	case SENSORTYPES::ULTRASONIC:
		return "";
	case SENSORTYPES::GENERIC:
		return "";
	}
	return "";
}

bool SensorViewConfiger::addSensorIdToStorage(const carla::ActorId& actorId, const carla::ActorId& sensorId) {
	for (auto& vehicle : carla->spawnedVehiclesByCarlaOSIService) {
		if (vehicle.second.vehicle == actorId) {
			vehicle.second.sensors.push_back(sensorId);
			return true;
		}
	}
	return false;
}

void SensorViewConfiger::deleteSpawnedSensorsOnExternalSpawnedVehicles() {
	for (auto& sensorId : carla->spawnedSensorsOnExternalSpawnedVehicles) {
		auto sensorActor = carla->world->GetActor(sensorId);
		if (sensorActor != nullptr) { sensorActor->Destroy(); };
	}
	carla->spawnedSensorsOnExternalSpawnedVehicles.clear();
}
